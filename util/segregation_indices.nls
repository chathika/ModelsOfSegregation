;; Calculates the Moran's I index (spatial autocorrelation of the color pattern)
;; calc-by-group?: if true, the index is caclulated by group, if false it is calculated by subgroup (toleance)
to-report moran-I [calc-by-group?]
  let n 0 ; number of turtles with at least one neighbor
  let sum-of-values 0
  let sum-of-squares 0


  ask turtles ; calculating the average value, variation and n:
  [
    foreach neighboring-patches [
      cur-patch ->
      let neighbor-resident [resident] of cur-patch
      if neighbor-resident != nobody [
        ask neighbor-resident [
          let value 0
          ifelse calc-by-group? [
            set value color-group
          ]
          [
            set value tolerance
          ]

          set n n + 1
          set sum-of-values sum-of-values + value
          set sum-of-squares sum-of-squares + value * value
        ]
      ]
    ]
  ]

  let average sum-of-values / n
  let variation sum-of-squares - sum-Of-Values * sum-of-values / n


  ; calculating the covariation
  let covariation 0
  let sum-of-weights  0

  ask turtles
  [

    let no-Of-neighbors length neighboring-patches ; no of turtles in the neighborhood
    let current-turtle-value 0

    ifelse calc-by-group? [
      set current-turtle-value color-group
    ]
    [
      set current-turtle-value tolerance
    ]


    foreach neighboring-patches [
      [cur-patch] ->
      let neighbor-resident [resident] of cur-patch
      if neighbor-resident != nobody [
        ask neighbor-resident [
          ;; "current-turtle-value" is the value of the turtle that is in the "center" while
          ;; "neighbor-value" is the value of one of its neighbors:

          let neighbor-value 0
          ifelse calc-by-group? [
            set neighbor-value color-group
          ]
          [
            set neighbor-value tolerance
          ]

          set covariation covariation + (current-turtle-value - average) * (neighbor-value - average) / no-of-neighbors
          set sum-of-weights sum-Of-weights + 1 / no-of-Neighbors
        ]
      ]
    ]
  ]

  ifelse variation * sum-of-weights > 0 [
    report n * covariation / (variation * sum-of-weights)
  ]
  [
    report -1
  ]
end

;; reports the c-index
to-report c-index
  mark-areas
  let size-of-blue-patch 0
  let size-of-green-patch 0
  let size-of-integrated-patch 0
  let total-size 0

  ask patches [

    set total-size total-size + 1
    if c-index-area = 1 [
      set size-of-blue-patch size-of-blue-patch + 1
    ]

    if c-index-area = 2 [
      set size-of-green-patch size-of-green-patch + 1
    ]

    if c-index-area = 3 [
      set size-of-integrated-patch size-of-integrated-patch + 1
    ]
  ]


  report (min (list (size-of-blue-patch) (size-of-green-patch) (size-of-integrated-patch))) / total-size

end


;; Marks the C index areas:
;; 1 represents homogeneous Blue area
;; 2 represents homogeneous Green area
;; 3 represents an integrated area
;; 4 represents the boundary
to mark-areas
  ask patches
  [
    set c-index-area 3 ; before marking the turtles, we set the values of all of them to 3 (which represents integrated area)
  ]

  mark-homogeneous-areas
  mark-homogeneous-boundary

end